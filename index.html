<html><head>
  <title>3D Ball Rolling Game - Multiple Levels with Holes</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100%; height: 100% }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 14px;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #winMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: 'Arial Black', sans-serif;
      font-size: 72px;
      text-align: center;
      text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
      opacity: 0;
      transition: opacity 1s;
      display: none;
    }
    #fireworks {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
    }
    #coinCount {
      position: absolute;
      top: 10px;
      right: 10px;
      color: gold;
      font-family: Arial, sans-serif;
      font-size: 24px;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #levelInfo {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #credits {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 14px;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }

    #timer {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    @keyframes rainbow {
      0% { color: red; }
      14% { color: orange; }
      28% { color: yellow; }
      42% { color: green; }
      56% { color: blue; }
      70% { color: indigo; }
      84% { color: violet; }
      100% { color: red; }
    }
    #winMessage span {
      display: inline-block;
      animation: rainbow 5s linear infinite, bounce 0.5s ease-in-out infinite alternate;
    }
    @keyframes bounce {
      from { transform: translateY(0); }
      to { transform: translateY(-20px); }
    }
  </style>
  </head>
  <body>
  <div id="instructions">
    Use WASD or Arrow keys to roll the rainbow ball.<br>
    Collect all spinning coins and reach the checkered platform to advance to the next level!<br>
    Be careful of holes - falling in one will reset the level!
  </div>
  <div id="winMessage">
    <span>Y</span><span>o</span><span>u</span> <span>W</span><span>i</span><span>n</span><span>!</span>
  </div>
  <div id="fireworks"></div>
  <div id="coinCount">Coins Remaining: 0</div>
  <div id="levelInfo">Level: 1</div>
  <div id="credits">Created by NotIshi28</div>
  <div id="timer">Time: 00:00.000</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
  <script>
    let scene, camera, renderer, ball, platform;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let acceleration = new THREE.Vector3();
    let walls = [];
    let coins = [];
    let holes = [];
    let coinsRemaining = 0;
    let clouds = [];
    let currentLevel = 1;
    let totalLevels = 5;
    let gameWon = false;
    let startTime;
    let timerInterval;
    
    // Sound effects
    const sounds = {
      coinCollect: new Howl({
        src: ['https://freesound.org/data/previews/162/162805_2578041-lq.mp3'],
        volume: 0.5
      }),
      levelComplete: new Howl({
        src: ['https://freesound.org/data/previews/122/122255_1074082-lq.mp3'],
        volume: 0.5
      }),
      fallInHole: new Howl({
        src: ['https://freesound.org/data/previews/326/326133_3271346-lq.mp3'],
        volume: 0.5
      }),
      backgroundMusic: new Howl({
        src: ['https://freesound.org/data/previews/560/560738_12295155-lq.mp3'],
        volume: 0.3,
        loop: true,
      }),
      winSound: new Howl({
        src: ['https://freesound.org/data/previews/258/258142_4631294-lq.mp3'],
        volume: 0.5
      })
    };
    
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
  
      // Improved Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
  
      // Improved shadow settings
      directionalLight.shadow.mapSize.width = 4096;
      directionalLight.shadow.mapSize.height = 4096;
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -25;
      directionalLight.shadow.camera.right = 25;
      directionalLight.shadow.camera.top = 25;
      directionalLight.shadow.camera.bottom = -25;
  
      // Enable shadow rendering
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
      loadLevel(currentLevel);
  
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
  
      // Start background music after a short delay
      setTimeout(() => {
        sounds.backgroundMusic.play();
      }, 3000);
  
      startTimer();
      animate();
    }


    function startTimer() {
      startTime = Date.now();
      timerInterval = setInterval(updateTimer, 1);
    }
  
    function updateTimer() {
      const currentTime = Date.now();
      const elapsedTime = new Date(currentTime - startTime);
      const minutes = String(elapsedTime.getUTCMinutes()).padStart(2, '0');
      const seconds = String(elapsedTime.getUTCSeconds()).padStart(2, '0');
      const milliseconds = String(elapsedTime.getUTCMilliseconds()).padStart(3, '0');
      document.getElementById('timer').textContent = `Time: ${minutes}:${seconds}.${milliseconds}`;
    }
  
    function loadLevel(level) {
      // Clear existing level
      clearLevel();
  
      // Set background color based on level
      if (level === 5) {
        scene.background = new THREE.Color(0xff0000); // Red background for level 5
      } else {
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background for other levels
      }
  
      // Create new level
      createBall();
      createPlatform();
      createWalls(level);
      createCoins(level);
      createHoles(level);
      createClouds();
      createWinPlatform(level);
  
      // Update level info
      document.getElementById('levelInfo').textContent = `Level: ${level}`;
      updateCoinCounter();
    }
  
    function clearLevel() {
      // Remove all objects from the scene except lights
      while(scene.children.length > 0){ 
        scene.remove(scene.children[0]); 
      }
      
      // Re-add lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Improved shadow settings
      directionalLight.shadow.mapSize.width = 4096;
      directionalLight.shadow.mapSize.height = 4096;
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -25;
      directionalLight.shadow.camera.right = 25;
      directionalLight.shadow.camera.top = 25;
      directionalLight.shadow.camera.bottom = -25;
  
      // Reset arrays and counters
      walls = [];
      coins = [];
      holes = [];
      clouds = [];
      coinsRemaining = 0;
    }
  
    function createBall() {
      const geometry = new THREE.SphereGeometry(0.5, 32, 32);
      const rainbowTexture = createRainbowTexture();
      const material = new THREE.MeshPhongMaterial({ map: rainbowTexture });
      ball = new THREE.Mesh(geometry, material);
      ball.position.set(-9, 0.5, -9); // Starting position in the corner
      ball.castShadow = true;
      scene.add(ball);
    }
  
    function createPlatform() {
      const platformGeometry = new THREE.BoxGeometry(20, 0.1, 20);
      const grassTexture = createGrassTexture();
      const platformMaterial = new THREE.MeshPhongMaterial({ map: grassTexture });
      platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.set(0, -0.05, 0);
      platform.receiveShadow = true;
      scene.add(platform);
    }
    

    function createWalls(level) {
      const brickTexture = createBrickTexture();
  
      // Outer walls
      createWall(0, 0.5, -10, 20, 1, 0.1, brickTexture);  // North wall
      createWall(0, 0.5, 10, 20, 1, 0.1, brickTexture);   // South wall
      createWall(-10, 0.5, 0, 0.1, 1, 20, brickTexture);  // West wall
      createWall(10, 0.5, 0, 0.1, 1, 20, brickTexture);   // East wall
  
      // Level-specific walls
      switch(level) {
        case 1:
          createWall(-7, 0.5, -3, 6, 1, 0.1, brickTexture);
          createWall(7, 0.5, 3, 6, 1, 0.1, brickTexture);
          createWall(-3, 0.5, 7, 0.1, 1, 6, brickTexture);
          createWall(3, 0.5, -7, 0.1, 1, 6, brickTexture);
          createWall(0, 0.5, 0, 10, 1, 0.1, brickTexture);
          break;
        case 2:
          createWall(-5, 0.5, -5, 5, 1, 0.1, brickTexture);
          createWall(5, 0.5, 5, 5, 1, 0.1, brickTexture);
          createWall(0, 0.5, 0, 0.1, 1, 10, brickTexture);
          break;
        case 3:
          createWall(-7, 0.5, -7, 5, 1, 0.1, brickTexture);
          createWall(7, 0.5, 7, 5, 1, 0.1, brickTexture);
          createWall(-7, 0.5, 7, 5, 1, 0.1, brickTexture);
          createWall(7, 0.5, -7, 5, 1, 0.1, brickTexture);
          break;
        case 4:
          createWall(-6, 0.5, -6, 8, 1, 0.1, brickTexture);
          createWall(6, 0.5, 6, 8, 1, 0.1, brickTexture);
          createWall(-6, 0.5, 6, 8, 1, 0.1, brickTexture);
          createWall(6, 0.5, -6, 8, 1, 0.1, brickTexture);
          createWall(0, 0.5, 0, 12, 1, 0.1, brickTexture);
          createWall(0, 0.5, 0, 0.1, 1, 12, brickTexture);
          break;
        case 5:
          // Maze-like structure for the final level
          createWall(-5, 0.5, -5, 10, 1, 0.1, brickTexture);
          createWall(5, 0.5, 5, 5, 1, 0.1, brickTexture);
          createWall(-5, 0.5, 0, 10, 1, 0.1, brickTexture);
          createWall(5, 0.5, 0, 5, 1, 0.1, brickTexture);
          createWall(-5, 0.5, 5, 0.1, 1, 5, brickTexture);
          createWall(5, 0.5, -5, 0.1, 1, 10, brickTexture);
          createWall(0, 0.5, -5, 0.1, 1, 5,  brickTexture);
          createWall(0, 0.5, 5, 0.1, 1, 5, brickTexture);
          break;
      }
    }
  
    function createCoins(level) {
      const coinTexture = createCoinTexture();
      switch(level) {
        case 1:
          createCoin(-7, 0.5, -7, coinTexture);
          createCoin(7, 0.5, -7, coinTexture);
          createCoin(7, 0.5, 7, coinTexture);
          createCoin(-5, 0.5, 2, coinTexture);
          createCoin(5, 0.5, -2, coinTexture);
          break;
        case 2:
          createCoin(-8, 0.5, -8, coinTexture);
          createCoin(8, 0.5, -8, coinTexture);
          createCoin(8, 0.5, 8, coinTexture);
          createCoin(-8, 0.5, 8, coinTexture);
          createCoin(0, 0.5, 0, coinTexture);
          createCoin(-4, 0.5, 4, coinTexture);
          createCoin(4, 0.5, -4, coinTexture);
          break;
        case 3:
          for (let i = -8; i <= 8; i += 4) {
            for (let j = -8; j <= 8; j += 4) {
              if (i !== 0 || j !== 0) {
                createCoin(i, 0.5, j, coinTexture);
              }
            }
          }
          break;
        case 4:
          for (let i = -7; i <= 7; i += 2) {
            for (let j = -7; j <= 7; j += 2) {
              if (Math.abs(i) % 4 !== 0 || Math.abs(j) % 4 !== 0) {
                createCoin(i, 0.5, j, coinTexture);
              }
            }
          }
          break;
        case 5:
          createCoin(-7, 0.5, -7, coinTexture);
          createCoin(-7, 0.5, 7, coinTexture);
          createCoin(7, 0.5, -7, coinTexture);
          createCoin(7, 0.5, 7, coinTexture);
          createCoin(-2.5, 0.5, -2.5, coinTexture);
          createCoin(-2.5, 0.5, 2.5, coinTexture);
          createCoin(2.5, 0.5, -2.5, coinTexture);
          createCoin(2.5, 0.5, 2.5, coinTexture);
          break;
      }
      coinsRemaining = coins.length;
      updateCoinCounter();
    }
  
    function createHoles(level) {
      const holeGeometry = new THREE.CircleGeometry(0.5, 32);
      const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      
      switch(level) {
        case 1:
          createHole(-3, 0.01, -3, holeGeometry, holeMaterial);
          createHole(3, 0.01, 3, holeGeometry, holeMaterial);
          break;
        case 2:
          createHole(-6, 0.01, 0, holeGeometry, holeMaterial);
          createHole(6, 0.01, 0, holeGeometry, holeMaterial);
          createHole(0, 0.01, -6, holeGeometry, holeMaterial);
          createHole(0, 0.01, 6, holeGeometry, holeMaterial);
          break;
        case 3:
          for (let i = -6; i <= 6; i += 4) {
            for (let j = -6; j <= 6; j += 4) {
              if (i !== 0 || j !== 0) {
                createHole(i, 0.01, j, holeGeometry, holeMaterial);
              }
            }
          }
          break;
        case 4:
          for (let i = -8; i <= 8; i += 4) {
            for (let j = -8; j <= 8; j += 4) {
              if (i !== 0 || j !== 0) {
                createHole(i, 0.01, j, holeGeometry, holeMaterial);
              }
            }
          }
          createHole(0, 0.01, 0, holeGeometry, holeMaterial);
          break;
        case 5:
          // Many holes for the final level
          for (let i = -9; i <= 9; i += 3) {
            for (let j = -9; j <= 9; j += 3) {
              if ((i !== -9 || j !== -9) && (i !== 9 || j !== -9)) { // Avoid start and end positions
                createHole(i, 0.01, j, holeGeometry, holeMaterial);
              }
            }
          }
          break;
      }
    }
  
    function createHole(x, y, z, geometry, material) {
      const hole = new THREE.Mesh(geometry, material);
      hole.position.set(x, y, z);
      hole.rotation.x = -Math.PI / 2;
      scene.add(hole);
      holes.push(hole);
    }
  
    function createWinPlatform(level) {
      const winPlatformGeometry = new THREE.BoxGeometry(2, 0.1, 2);
      const winPlatformMaterial = new THREE.MeshPhongMaterial({ 
        map: createCheckerboardTexture()
      });
      const winPlatform = new THREE.Mesh(winPlatformGeometry, winPlatformMaterial);
      switch(level) {
        case 1:
          winPlatform.position.set(-8, 0, 8);
          break;
        case 2:
          winPlatform.position.set(8, 0, -8);
          break;
        case 3:
          winPlatform.position.set(0, 0, 0);
          break;
        case 4:
          winPlatform.position.set(9, 0, 9);
          break;
        case 5:
          winPlatform.position.set(9, 0, -9);
          break;
      }
      winPlatform.receiveShadow = true;
      scene.add(winPlatform);
    }
  
    function createRainbowTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const context = canvas.getContext('2d');
  
      const gradient = context.createLinearGradient(0, 0, 0, 256);
      gradient.addColorStop(0, 'red');
      gradient.addColorStop(1/6, 'orange');
      gradient.addColorStop(2/6, 'yellow');
      gradient.addColorStop(3/6, 'green');
      gradient.addColorStop(4/6, 'blue');
      gradient.addColorStop(5/6, 'indigo');
      gradient.addColorStop(1, 'violet');
  
      context.fillStyle = gradient;
      context.fillRect(0, 0, 256, 256);
  
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }


  </script>
  </body></html>